#!/usr/bin/perl
#
# This script generates an include file for the GAUSSLIN function
# that specifies the values of the different parameters for different
# red shift and fractions of point masses.
#
# The input files are assumed to be matrices of the same size and with
# the same red shift and fraction of point masses.
#

$thisscript = 'partof.pl';

#
# Use version 2 for the continous pdf.
#
@files = ( 'm0v2.out' , 'sigmav2.out' , 'bv2.out' );


my %paras;
foreach $file ( @files ) {
  open FP , $file;
  my @lines = <FP>;
  close FP;
  
  #
  # The first line contains the red shifts.
  #
  my @z = split( /[ \t\n]+/ , shift @lines );
  shift @z if $z[0] eq "";
  shift @z;   # The first redshift is a dummy
  push @zs , \@z;

  #
  # The first column contains the fraction of point masses
  #
  my @fp;
  my @parvals;
  foreach $line ( @lines ) {
    my @numbers = split( /[ \t\n]+/ , $line );
    shift @numbers if $numbers[0] eq "";
    push @fp , shift @numbers; # The first value is the fp.
    push @parvals , join "," , @numbers;
  }
  push @fps , \@fp;

  ( $name , $ext ) = split /\./ , $file;
  $paras{$name} = \@parvals;  
}

#
# Check that the red shifts and the fp are the same for all
# parameter files.
#
for ( $n = 1; $n <= $#zs; $n++ ) {
  my @firz = @{$zs[0]};
  my @thiz = @{$zs[$n]};
  my $firf = @{$fps[0]};
  my $thif = @{$fps[$n]};
  my $sum;#  = 0.0;
  $sum = 0.0;
  for ( my $k = 0; $k <= $#firz; $k++ ) {
    $sum = $sum + $firz[$k] - $thiz[$k] + $firf[$k] - $thif[$k-1];
  }
  next if $sum == 0;
  die "The red shifts and fraction of point masses are not the same for ",
  "the different parameter matrices!\n";
}

open FP , ">gausslin.inc";

print FP <<WE_ARE_FINISHED;
C 
C THIS FILE IS AUTOGENERATED BY $thisscript AND SHOULD NOT BE EDITED
C MANUALLY.
C
  
C     ****d* snalys/GAUSS_LIN_MATRICES [1.0] *
C   NAME
C     GAUSS_LIN_MATRICES -- matrices for the GAUSSLIN function.
C
C   DESCRIPTION
C     These parameters are included in GAUSSLIN function. They define
C     the values for the different parameters for different red shifts
C     and fraction of point masses.
C
C     GLZ     - the array of red shifts to which the table correspond
C               (each column in a table/matrix are calculated for the
C	        same red shift)
C     GLFP    - the array of fractions of point masses to which the table
C               correspond to (each row in a table/matrix are calculated
C               for the same fraction of point masses)
C     GLZNR   - the number of columns of the matrices.
C     GLFPNR  - the number of rows or the matrices.
C     GLM0    - values for the M0 parameter.
C     GLSIGMA - values for the sigma parameter.
C     GLB     - values for the b parameter.
C
C   AUTHOR
C     Rahman Amanullah (rahman\@physto.se)
C
C   CREATION DATE
C     2001-10-12
C
C     ***
WE_ARE_FINISHED


my @z = @{$zs[0]};
my $nrz = $#z+1;
my @fp = @{$fps[0]};
my $nrf = $#fp+1;

print FP "      INTEGER GLZNR, GLFPNR, GLN, GLZI, GLFI\n";
print FP "      PARAMETER ( GLZNR = $nrz , GLFPNR = $nrf , GLZI = 1, GLFI = 2 )\n\n";

#
# First, print the redshift and pointmass columns.
#
print FP "      REAL GLZ($nrz), GLFP($nrf)\n";
print FP "      DATA (GLZ(GLN),GLN = 1, $nrz) /\n",
  &datastr( join( ",", @z) ), "     \$/\n";
print FP "      DATA (GLFP(GLN),GLN = 1, $nrf) /\n",
  &datastr( join( ",", @fp) ), "     \$/\n";
print FP "\n";

#
# Print all the data entries for the matrices.
#
foreach $par (keys %paras) {
  print FP "      REAL GL",uc(substr($par,0,length($par)-2)),"($nrf,$nrz)\n";
  my @lines = @{$paras{$par}};
  for ( my $n = 0; $n < $nrf ; $n++ ) {
    print FP "      DATA (GL",uc(substr($par,0,length($par)-2)),"(",
      $n+1,",GLN), GLN = 1, $nrz) /\n",
      &datastr( $lines[$n] ), "     \$/\n";
  }
  print FP "\n\n";
}

print FP <<WE_ARE_FINISHED;
C
C End of gausslin.inc
C
WE_ARE_FINISHED

close FP;

#
# Divides the input string, and returns it as a fortranstring which starts
# with 7 blank spaces and does not pass beyond column 72. Instead it is
# continued on the next line with a continuation symbol in column 6.
#
sub datastr {
  my $str = shift;

  my $len = length $str;
  $ret = "";
  
  my $off = 0;
  while ( $len-$off > 72-6 ) {
    $ret = $ret."     \$".substr( $str , $off, (72-6)-$off)."\n";
    $off = $off + (72 - 6);
  }
  $ret = $ret."     \$".substr( $str , $off, $len-$off)."\n";

  return $ret;
}
# EOF
