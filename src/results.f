C     ****f* snalys/RESULTS *
C
C   NAME
C     RESULTS -- print and plot the results of snalys.
C
C   DESCRIPTION
C     Print and plot the results of snalys to the specified output
C     devices.
C
C   AUTHOR
C     Rahman Amanullah (rahman@physto.se)
C
C   CREATION DATE
C     2000-10-25
C
C   USAGE
C     CALL RESULTS( STIME, F_DEN, MAGDIST, BIN, GRI, GEN, GST, POW, PST,
C                   DAV, DST, GERR, DERR, CORR )
C
C   INPUTS
C     STIME     - The start time for the execution (in unix format)
C     F_DEN     - the grid array of type REAL
C     MAGDIST   - the vector containing the magnitude
C                 distribution with the fitted cosmology.
C     BIN       - array containing the contour levels
C     GRI       - the best fit from the GRIDSEARCH.
C     GEN       - the best fit from GENETIC.
C     GST       - the start values for GENETIC.
C     POW       - the best fit from POWELL.
C     PST       - the start values for POWELL.
C     DAV       - the best fit from DAVIDO.
C     DST       - the start values for DAVIDO.
C     GERR      - the estimated errors from GRIDSEARCH.
C     DERR      - the estimated errors from DAVIDO.
C     CORR      - the estimated correlation matrix from DAVIDO.
C
C   TODO
C     - Change so that the output is stored in a fits file instead
C       of ASCII. This will reduce the size of the files and make
C       it easier to import in a more advanzed plotting program.
C
C   HISTORY
C     2001-09-13 Added the calculation of the CPU-time and changed
C                so that the total execution time for the program
C                is written here instead of in main.f.
C     2003-07-10 Removed all plotting posibilities.
C
C     ***
      SUBROUTINE RESULTS(STIME, F_DEN, MAGDIST, BIN, GRI, GEN, GST, POW,
     $     PST , DAV, DST, GERR, DERR, CORR)
      IMPLICIT NONE
      REAL STIME

      INCLUDE 'cosmo.inc'
      INCLUDE 'error.inc'
      INCLUDE 'operation.inc'
      INCLUDE 'snalys.inc'
      INCLUDE 'probability.inc'
      INCLUDE 'supernova.inc'
      INCLUDE 'io.inc'

      REAL F_DEN(*),MAGDIST(*),GRI(*),GEN(*),POW(*),DAV(*), DERR(*),
     $     CORR(NR_PAR,NR_PAR), GERR(2,*), BIN(*), GST(*), PST(*),
     $     DST(*)

C  
C     Local variables
C  
      INTEGER IDX(NR_PAR), LEN(NR_PAR), I, N, K, J, MATLEN(2), IOS
      INTEGER CONT_MAX, GET_ARRAY_IDX
      PARAMETER ( CONT_MAX = 1000 )
      REAL C_NR_GET, C_START_GET, C_END_GET, C_STEP_GET
      REAL LOGMLFUNC, TMP
      REAL CONT(CONT_MAX,CONT_MAX)
      REAL C(10), ML_MIN, TR(6), XELLIPSE, YELLIPS, MAT(500000)
      EXTERNAL XELLIPSE, YELLIPSE

      LOGICAL SETUP_PLOT, PRINTOUT
      REAL RHO, SIGMA1, SIGMA2, MU1, MU2, NR_SIGMA, TOTAL, ETIME,
     $     ELAPSED(2)
      COMMON /ELLIPSE/RHO, SIGMA1, SIGMA2, MU1, MU2, NR_SIGMA

      CHARACTER*24 CTIME, EXETIME, CPUTOTAL, CPUUSER, CPUSYSTEM

      PRINTOUT = .TRUE.

C
C       Write some information to the console.
C

C     WRITE (STDOUT,'(A,I7)') 'Supernovae used for this fit: ',
C    $     SN_USED
      CALL CPU_TIME(ETIME)
      CALL SEC2STR( DBLE(ETIME - STIME) , EXETIME )
C     WRITE (STDOUT,'(2A)') 'Total execution time: ', EXETIME

      IF ( OPER(FITS) ) THEN
         CALL RESFITS( STIME, F_DEN, GRI, GERR )
      ELSE
         OPEN( OFID, FILE=OUTFILE, IOSTAT=IOS, STATUS='UNKNOWN' )
         IF (IOS.NE.0) THEN
            IF ( OFID .EQ. STDOUT ) THEN
               OFID = -1
            ELSE
               OFID = STDOUT
            ENDIF
            PRINTOUT = .FALSE.
         ENDIF
         IF ( PRINTOUT ) THEN
            WRITE (OFID,'(A)')
     $           '# THIS IS THE OUTPUT GENERATED BY SNALYS'
            WRITE (OFID,'(A)')
     $           '# ======================================'
            WRITE (OFID,'(A,I7)') '# The number of supernovae used: ',
     $           SN_USED
            WRITE (OFID,'(2A,I2,A)') '# The number of parameters ',
     $           'estimated: ',NR_VAR,'\n'
            IF ( OPER(FLAT) ) THEN
               WRITE (OFID,'(A)') '# Flat universe assumption: yes'
            ELSE
               WRITE (OFID,'(A)') '# Flat universe assumption: no'
            ENDIF
            IF ( OPER(DO_BOS) ) THEN
               WRITE (OFID,'(A)') '# Prior from BOS: yes'
            ELSE
               WRITE (OFID,'(A)') '# Prior from BOS: no'
            ENDIF
            IF ( OPER(DO_CMB) ) THEN
               WRITE (OFID,'(A)') '# Prior from CMB: yes'
            ELSE
               WRITE (OFID,'(A)') '# Prior from CMB: no'
            ENDIF
            IF ( OPER(DO_OM) ) THEN
               WRITE (OFID,'(A)') '# Prior on Omega_M: yes'
            ELSE
               WRITE (OFID,'(A)') '# Prior on Omega_M: no'
            ENDIF
C
C              Print the time related stuff.
C
            WRITE (OFID,'(2A)') '# Execution started at: ',
     $           CTIME(TIME())
            WRITE (OFID,'(2A)') '# Total execution time: ', EXETIME

C  
C              The minimum obtained with Powell's minimization routine.
C  
            IF ( OPER(DO_POWELL) ) THEN
               CALCDERIV = .FALSE.
               WRITE (OFID,'(A)') '\n# Powell Minimization'
               WRITE (OFID,'(A)') '# ==================='
               WRITE (OFID,'(A)') '# Start values '
               DO N = 1, NR_VAR
                  WRITE (OFID,'(A,F7.3)') P_NAMES(N), PST(N)
               ENDDO
               WRITE (OFID,'(2A,F10.3)') '# The min of the ML ',
     $              'function (powell): ', LOGMLFUNC( POW, POW )
               WRITE (OFID,'(A)') '# Cosmology (powell)'
               DO N = 1,NR_VAR
                  WRITE (OFID,'(A10,F10.6)') P_NAMES(N),POW(N)
               ENDDO
               IF ( OPER(FLAT).AND.O_M.GE.1 )
     $              WRITE (OFID,'(A10,F10.6)') 'omega_x   ',
     $              1.0 - POW(O_M)
            ENDIF
C  
C              The minimum obtained with Genetic's minimization routine.
C  
            IF ( OPER(DO_GENETIC) ) THEN
               CALCDERIV = .FALSE.
               WRITE (OFID,'(A)') '\n# Genetic Minimization'
               WRITE (OFID,'(A)') '# ==================='
               WRITE (OFID,'(2A,F10.3)') '# The min of the ML ',
     $              'function (genetic): ', LOGMLFUNC( GEN, GEN )
               WRITE (OFID,'(A)') '# Cosmology (genetic)'
               DO N = 1,NR_VAR
                  WRITE (OFID,'(A10,F10.6)') P_NAMES(N),GEN(N)
               ENDDO
               IF ( OPER(FLAT).AND.O_M.GE.1 )
     $              WRITE (OFID,'(A10,F10.6)') 'omega_x   ',
     $              1.0 - GEN(O_M)
            ENDIF
C     
C              The minimum obtained with Davidon's minimization routine.
C  
            IF ( OPER(DO_DAVIDON) ) THEN
               CALCDERIV = .FALSE.
               WRITE (OFID,'(A)') '\n# Davidon Minimization'
               WRITE (OFID,'(A)') '# ===================='
               WRITE (OFID,'(A)') '# Start values '
               DO N = 1, NR_VAR
                  WRITE (OFID,'(A,F7.3)') P_NAMES(N), DST(N)
               ENDDO
               WRITE (OFID,'(2A,F10.3)') '# The min of the ML ',
     $              'function (davidon): ', LOGMLFUNC( DAV, DAV )
               WRITE (OFID,'(A)') '# Cosmology (davidon)'
               DO N = 1,NR_VAR
                  WRITE (OFID,'(A,F9.6,A5,F9.6)') P_NAMES(N),DAV(N),
     $                 ' +/- ', DERR(N)*SIG_Z(NRSIG,1)
               ENDDO
               IF ( OPER(FLAT).AND.O_M.GE.1 )
     $              WRITE (OFID,'(A10,F9.6,A5,F9.6)') 'omega_x   ',
     $              1.0-DAV(O_M),' +/- ', DERR(O_M)*SIG_Z(NRSIG,1)
               WRITE (OFID,'(A)') '# Correlation matrix (davidon)'
               WRITE (OFID,'(A10,15A11)') ' ',(P_NAMES(N),N=1,NR_VAR)
               DO N = 1,NR_VAR
                  WRITE (OFID,'(A10,15F10.5)') P_NAMES(N),
     $                 (CORR(I,N),I=1,NR_VAR)
               ENDDO
            ENDIF
C     
C              The minimum obtained from the grid search.
C  
            IF ( OPER(DO_GRID) ) THEN
               WRITE (OFID,'(A)') '\n# Grid Search'
               WRITE (OFID,'(A)') '# ==========='
               WRITE (OFID,'(2A,F10.3)') '# The min of the ML ',
     $              'function (grid): ', GRI(NR_VAR+1)
               
C     Print the most probable cosmology to standard output.
               WRITE (OFID,'(A)') '# Cosmology (grid)'
               DO N = 1, NR_VAR
                  WRITE (OFID,'(A10,F9.6,A3,E10.2,A3,E10.2)'),
     $                 P_NAMES(N),GRI(N),' + ',GERR(2,N),' - ',GERR(1,N)
               ENDDO
C
C     For a flat universe we also needs to change the signs of the
C     errors.
C
               IF ( OPER(FLAT).AND.O_M.GE.1.AND. .NOT. OPER(XDIM) )
     $              WRITE (OFID,'(A10,F9.6,A3,E10.2,A3,E10.2)')
     $              'OMEGAX   ',1.0 - GRI(O_M),' + ',-GERR(1,O_M),' - ',
     $              -GERR(2,O_M)
               IF ( OPER(FLAT).AND.O_M.GE.1.AND. OPER(XDIM) )
     $              WRITE (OFID,'(A10,F9.6,A3,E10.2,A3,E10.2)')
     $              'OMEGARC   ',(1.D0 - GRI(O_M))**2/4.D0,' + ',
     $              (1.D0 - GRI(O_M))/2.D0*GERR(2,O_M),' - ',
     $              (1.D0 - GRI(O_M))/2.D0*GERR(1,O_M)

               WRITE (OFID,'(A12,F12.6)') 'BEST_SCRIPTM', BEST_SCRIPTM

            ENDIF
            
C  
C             Print the entire grid vector
C  
            IF ( OPER(DO_GRID) ) THEN
               WRITE (OFID,'(A)') '# Conditions for grid search.'
               WRITE (OFID,'(A15,A7,A7,A7)') '# Parameter     ','start',
     $              'stop','nr.step'
               DO N=1,NR_VAR
                  WRITE (OFID,'(A15,F5.2,F5.2,I5)') P_NAMES(N),
     $                 C_START_GET(N),C_END_GET(N),INT(C_NR_GET(N))
               ENDDO
            ENDIF
            
            IF ( OPER(DO_GRID) ) THEN
               WRITE (OFID,'(A)') '# The ML-function from Grid Search'
               WRITE (OFID,'(20A)') '#',(P_NAMES(N),N=1,NR_VAR)
C     
C                 Calculate the total length of the array.
C  
               I = 1
               DO N = 1,NR_VAR
                  I = I*INT( C_NR_GET(N) )
               ENDDO
               DO N = 1,I
                  WRITE (OFID,*) F_DEN(N)
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      END
C
C End of RESULTS.
C


C     ****f* snalys/TENPROJ *
C
C   NAME
C     TENPROJ -- projecting a multi dimensional array
C
C   DESCRIPTION
C     Projecting a multi-dimensional array to a matrix.
C
C   AUTHOR
C     Rahman Amanullah (rahman@physto.se)
C
C   CREATION DATE
C     2000-10-25
C
C   USAGE
C     TENPROJ( ARRAY , MAT, NRCON, CON, NRDIM, ADIM, PLANE )
C
C   INPUTS
C     ARRAY  - the multi dimensional array.
C     MAT    - the resulting matrix
C     NRCON  - number of confidence levels to be plotted.
C     CON    - the confidence levels
C     NRDIM  - the number of dimensions of the array.
C     ADIM   - the dimensions of the array, e.g. (100 , 200 , 100)
C     PLANE  - the plane on which the projections should be made.
c
C   SIDE EFFECTS
C     MAT - will contain the projection.
C     CON - is modified for some mysterious reasons.
C
C     ***
      SUBROUTINE TENPROJ( TEN, MAT, NRCON, CON, NRDIM, TEN_DIM, PLANE )
      IMPLICIT NONE
      REAL TEN(*), MAT(*), CON(*)
      INTEGER NRCON, NRDIM, TEN_DIM(*), PLANE(*)

C  
C       The largest allowed dimension of the array.
C  
      INTEGER MAX_DIM, CONTNR
      PARAMETER ( MAX_DIM = 20, CONTNR = 5 )

      INTEGER N, I, TEN_IDX(MAX_DIM), MAT_IDX(2), TEN_LEN, MAT_LEN,
     $     MAT_DIM(2), GET_VECTOR_IDX, IDX(MAX_DIM)
      REAL TMP

C  
C        Reset the index vector.
C  
      DO N = 1, NRDIM
         IDX(N) = 1
      ENDDO
C  
C        Extract the matrix dimensions.
C  

      MAT_DIM(1) = TEN_DIM(PLANE(1))
      MAT_DIM(2) = TEN_DIM(PLANE(2))

C  
C        Reset the matrix.
C  
      MAT_LEN = MAT_DIM(1)*MAT_DIM(2)
      DO N = 1, MAT_LEN
         MAT(N) = 0.0
      ENDDO

C  
C        Calculate the number of elements in the .
C  
      TEN_LEN = 1
      DO N = 1, NRDIM
         TEN_LEN = TEN_LEN*TEN_DIM(N)
      ENDDO

C  
C        Sort the contour vector.
C  
      DO N = 1, NRCON - 1
         DO I = N + 1, NRCON
            IF ( CON(I).LT.CON(N) ) THEN
               TMP = CON(N)
               CON(N) = CON(I)
               CON(I) = TMP
            ENDIF
         ENDDO
      ENDDO

C     
C        Create the projected matrix.
C     
      DO N = 1, TEN_LEN
         CALL GET_NORMAL_IDX( NRDIM, N, TEN_DIM, TEN_IDX )
         MAT_IDX(1) = TEN_IDX(PLANE(1))
         MAT_IDX(2) = TEN_IDX(PLANE(2))
C  
C           Check in what contour interval the value lies and
C           what value should be assigned to the matrix.
C  
         DO I = 1, NRCON
            IF ( TEN(N).LT.CON(NRCON - I + 1) .AND.
     $           MAT(GET_VECTOR_IDX(2,MAT_DIM,MAT_IDX)).LT.REAL(I) )THEN
               MAT(GET_VECTOR_IDX(2,MAT_DIM,MAT_IDX)) = REAL(I)
            ENDIF
         ENDDO
      ENDDO

C  
C        Modify the contour vector so that its values corresponds
C        to the contours in the matrix.
C  
      DO N = 1, NRCON
         CON(N) = REAL(NRCON - N + 1) - 0.5
      ENDDO
      END
C
C   End of TENPROJ
C



C     ****f* snalys/XELLIPSE *
C
C   NAME
C     XELLIPSE -- gives the x-coordinates for an ellipse
C
C   DESCRIPTION
C     For a parametrized ellipse this returns a x-value which can
C     be used together with YELLIPSE to plot the ellipse.
C
C   AUTHOR
C     Rahman Amanullah (rahman@physto.se)
C
C   CREATION DATE
C     2000-10-25
C
C   USAGE
C     XELLIPSE(THETA)
C
C   INPUTS
C     THETA - theta is an angle between 0 and 2pi for which the
C             corresponding x-value will be calculated.
C
C   RESULTS
C     The corresponding x-value for the angle THETA
C
C     ***
      REAL FUNCTION XELLIPSE(THETA)
      IMPLICIT NONE
      REAL THETA

      
      INCLUDE 'probability.inc'

      REAL RHO,SIGMA1,SIGMA2,MU1,MU2,ALPHA,NR_SIGMA
      COMMON /ELLIPSE/RHO,SIGMA1,SIGMA2,MU1,MU2,NR_SIGMA

      XELLIPSE = SIGMA1*SIG_Z(NRSIG,INT(NR_SIGMA))*SQRT(ABS(
     $     (1 - RHO**2)/(1 - 2.*RHO*SIN(THETA)*COS(THETA))))*COS(THETA) 
     $     + MU1
      
      RETURN
      END
C
C End of XELLIPSE
C


C     ****f* snalys/YELLIPSE *
C
C   NAME
C     YELLIPSE -- gives the y-coordinates for an ellipse
C
C   DESCRIPTION
C     For a parametrized ellipse this returns a y-value which can
C     be used together with XELLIPSE to plot the ellipse.
C
C   AUTHOR
C     Rahman Amanullah (rahman@physto.se)
C
C   CREATION DATE
C     2000-10-25
C
C   USAGE
C     YELLIPSE(THETA)
C
C   INPUTS
C     THETA - theta is an angle between 0 and 2pi for which the
C             corresponding y-value will be calculated.
C
C   RESULTS
C     The corresponding y-value for the angle THETA
C
C     ***
      REAL FUNCTION YELLIPSE(THETA)
      IMPLICIT NONE
      REAL THETA

      INCLUDE 'probability.inc'

      REAL RHO,SIGMA1,SIGMA2,MU1,MU2,ALPHA,NR_SIGMA
      COMMON /ELLIPSE/RHO,SIGMA1,SIGMA2,MU1,MU2,NR_SIGMA

      YELLIPSE = SIGMA2*SIG_Z(NRSIG,INT(NR_SIGMA))*SQRT(ABS(
     $     (1 - RHO**2)/(1 - 2.*RHO*SIN(THETA)*COS(THETA))))*SIN(THETA)
     $     + MU2

      RETURN
      END 
C
C End of YELLIPSE
C

C
C End of results.f
C
